/*************************************************************************
 * libjson-rpc-cpp
 *************************************************************************
 * @file    CppServerCodeGenerator.cpp
 * @date    01.05.2013
 * @author  Peter Spiess-Knafl <dev@spiessknafl.at>
 * @license See attached LICENSE.txt
 ************************************************************************/

#include "generate.h"

#include <algorithm>
#include <sstream>

using namespace std;
using namespace jsonrpc;

extern const char* TEMPLATE_CPPSERVER_METHODBINDING;
extern const char* TEMPLATE_CPPSERVER_NOTIFICATIONBINDING;
extern const char* TEMPLATE_CPPSERVER_SIGCLASS;
extern const char* TEMPLATE_CPPSERVER_SIGCONSTRUCTOR;
extern const char* TEMPLATE_CPPSERVER_SIGMETHOD;
extern const char* TEMPLATE_CPPSERVER_SIGMETHOD_WITHOUT_PARAMS;
extern const char* TEMPLATE_CPPSERVER_SIGNOTIFICATION;
extern const char* TEMPLATE_CPPSERVER_SIGNOTIFICATION_WITHOUT_PARAMS;
extern const char* TEMPLATE_SERVER_ABSTRACTDEFINITION;
extern const char* TEMPLATE_CPPSERVER_GUARD1;
extern const char* TEMPLATE_CPPSERVER_GUARD2;
extern const char* TEMPLATE_EPILOG;

void CppServerCodeGenerator::generateStub() {
    StringVector classname;
    splitPackages(stubname, classname);
    writeLine("/**");
    writeLine(" * This file is generated by jsonrpcstub, DO NOT CHANGE IT MANUALLY!");
    writeLine(" */");
    writeNewLine();

    string stub_upper = stubname;
    std::transform(stub_upper.begin(), stub_upper.end(), stub_upper.begin(), ::toupper);
    replaceAll(stub_upper, "::", "_");

    writeLine(substitute(TEMPLATE_CPPSERVER_GUARD1, "<STUBNAME>", stub_upper));
    writeLine(substitute(TEMPLATE_CPPSERVER_GUARD2, "<STUBNAME>", stub_upper));
    writeNewLine();

    this->writeLine("#include <jsonrpccpp/rpclib.h>");
    this->writeNewLine();

    int depth = namespaceOpen(stubname);

    this->writeLine(substitute(TEMPLATE_CPPSERVER_SIGCLASS, "<stubname>", classname.at(classname.size() - 1)));
    this->writeLine("{");
    this->increaseIndentation();
    this->writeLine("public:");
    this->increaseIndentation();

    this->writeLine(substitute(TEMPLATE_CPPSERVER_SIGCONSTRUCTOR, "<stubname>", classname.at(classname.size() - 1)));
    this->writeLine("{");
    this->generateBindings();
    this->writeLine("}");

    this->writeNewLine();

    this->generateProcedureDefinitions();

    this->generateAbstractDefinitions();

    this->decreaseIndentation();
    this->decreaseIndentation();
    this->writeLine("};");
    this->writeNewLine();

    namespaceClose(depth);
    stub_upper = this->stubname;
    std::transform(stub_upper.begin(), stub_upper.end(), stub_upper.begin(), ::toupper);
    replaceAll(stub_upper, "::", "_");
    writeLine(substitute(TEMPLATE_EPILOG, "<STUBNAME>", stub_upper));
}

void CppServerCodeGenerator::generateBindings() {
    string tmp;
    this->increaseIndentation();
    for (ProcedureVector::const_iterator it = this->procedures.begin(); it != this->procedures.end(); ++it) {
        const Procedure& proc = *it;
        if (proc.GetProcedureType() == RPC_METHOD) {
            tmp = TEMPLATE_CPPSERVER_METHODBINDING;
        } else {
            tmp = TEMPLATE_CPPSERVER_NOTIFICATIONBINDING;
        }
        replaceAll(tmp, "<rawprocedurename>", proc.GetProcedureName());
        replaceAll(tmp, "<procedurename>", normalizeString(proc.GetProcedureName()));
        replaceAll(tmp, "<returntype>", toString(proc.GetReturnType()));
        replaceAll(tmp, "<parameterlist>", generateBindingParameterlist(proc));
        replaceAll(tmp, "<stubname>", this->stubname);

        if (proc.GetParameterDeclarationType() == PARAMS_BY_NAME) {
            replaceAll(tmp, "<paramtype>", "PARAMS_BY_NAME");
        } else {
            replaceAll(tmp, "<paramtype>", "PARAMS_BY_POSITION");
        }

        this->writeLine(tmp);
    }
    this->decreaseIndentation();
}

void CppServerCodeGenerator::generateProcedureDefinitions() {
    for (ProcedureVector::const_iterator it = this->procedures.begin(); it != this->procedures.end(); ++it) {
        const Procedure& proc = *it;
        if (proc.GetProcedureType() == RPC_METHOD) {
            if (!proc.GetParameters().empty()) {
                this->writeLine(substitute(TEMPLATE_CPPSERVER_SIGMETHOD, "<procedurename>",
                                           normalizeString(proc.GetProcedureName())));
            } else {
                this->writeLine(substitute(TEMPLATE_CPPSERVER_SIGMETHOD_WITHOUT_PARAMS, "<procedurename>",
                                           normalizeString(proc.GetProcedureName())));
            }
        } else {
            if (!proc.GetParameters().empty()) {
                this->writeLine(substitute(TEMPLATE_CPPSERVER_SIGNOTIFICATION, "<procedurename>",
                                           normalizeString(proc.GetProcedureName())));
            } else {
                this->writeLine(substitute(TEMPLATE_CPPSERVER_SIGNOTIFICATION_WITHOUT_PARAMS, "<procedurename>",
                                           normalizeString(proc.GetProcedureName())));
            }
        }

        this->writeLine("{");
        this->increaseIndentation();

        if (proc.GetProcedureType() == RPC_METHOD)
            this->write("response = ");
        this->write("this->");
        this->write(normalizeString(proc.GetProcedureName()) + "(");
        this->generateParameterMapping(proc);
        this->writeLine(");");

        this->decreaseIndentation();
        this->writeLine("}");
    }
}

void CppServerCodeGenerator::generateAbstractDefinitions() {
    string tmp;
    for (ProcedureVector::iterator it = this->procedures.begin(); it != this->procedures.end(); ++it) {
        Procedure& proc = *it;
        tmp = TEMPLATE_SERVER_ABSTRACTDEFINITION;
        string returntype = "void";
        if (proc.GetProcedureType() == RPC_METHOD)
            returntype = toCppType(proc.GetReturnType(), true);
        replaceAll(tmp, "<returntype>", returntype);
        replaceAll(tmp, "<procedurename>", normalizeString(proc.GetProcedureName()));
        replaceAll(tmp, "<parameterlist>", generateParameterDeclarationList(proc));
        this->writeLine(tmp);
    }
}

string CppServerCodeGenerator::generateBindingParameterlist(const Procedure& proc) {
    stringstream parameter;
    const parameterNameList_t& list = proc.GetParameters();

    for (parameterNameList_t::const_iterator it2 = list.begin(); it2 != list.end(); ++it2) {
        parameter << "\"" << it2->first << "\"," << toString(it2->second) << ",";
    }
    return parameter.str();
}

extern string toCppConversion(jsontype_t type);

void CppServerCodeGenerator::generateParameterMapping(const Procedure& proc) {
    string tmp;
    const parameterNameList_t& params = proc.GetParameters();
    int i = 0;
    for (parameterNameList_t::const_iterator it2 = params.begin(); it2 != params.end(); ++it2) {
        if (proc.GetParameterDeclarationType() == PARAMS_BY_NAME) {
            tmp = "request[\"" + it2->first + "\"]" + toCppConversion(it2->second);
        } else {
            stringstream tmp2;
            tmp2 << "request[" << i << "u]" << toCppConversion(it2->second);
            tmp = tmp2.str();
        }
        this->write(tmp);
        if (it2 != --params.end()) {
            this->write(", ");
        }
        i++;
    }
}

const char* TEMPLATE_CPPSERVER_METHODBINDING =
    "this->bindAndAddMethod(jsonrpc::Procedure(\"<rawprocedurename>\", <paramtype>, <returntype>, <parameterlist> "
    "NULL), &<stubname>::<procedurename>I);";
const char* TEMPLATE_CPPSERVER_NOTIFICATIONBINDING =
    "this->bindAndAddNotification(jsonrpc::Procedure(\"<rawprocedurename>\", <paramtype>, <parameterlist> NULL), "
    "&<stubname>::<procedurename>I);";
const char* TEMPLATE_CPPSERVER_SIGCLASS = "class <stubname> : public jsonrpc::AbstractServer<<stubname>>";
const char* TEMPLATE_CPPSERVER_SIGCONSTRUCTOR =
    "<stubname>(jsonrpc::HttpServer &conn) : jsonrpc::AbstractServer<<stubname>>(conn)";
const char* TEMPLATE_CPPSERVER_SIGMETHOD =
    "inline virtual void <procedurename>I(const Json::Value &request, Json::Value &response)";
const char* TEMPLATE_CPPSERVER_SIGMETHOD_WITHOUT_PARAMS =
    "inline virtual void <procedurename>I(const Json::Value &/*request*/, Json::Value &response)";
const char* TEMPLATE_CPPSERVER_SIGNOTIFICATION = "inline virtual void <procedurename>I(const Json::Value &request)";
const char* TEMPLATE_CPPSERVER_SIGNOTIFICATION_WITHOUT_PARAMS =
    "inline virtual void <procedurename>I(const Json::Value &/*request*/)";
const char* TEMPLATE_SERVER_ABSTRACTDEFINITION = "virtual <returntype> <procedurename>(<parameterlist>) = 0;";
const char* TEMPLATE_CPPSERVER_GUARD1 = "#ifndef JSONRPC_CPP_STUB_<STUBNAME>_H_";
const char* TEMPLATE_CPPSERVER_GUARD2 = "#define JSONRPC_CPP_STUB_<STUBNAME>_H_";
const char* TEMPLATE_EPILOG = "#endif //JSONRPC_CPP_STUB_<STUBNAME>_H_";
